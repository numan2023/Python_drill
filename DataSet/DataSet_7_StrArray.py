# 文字列の配列

# 縦 H マス、横 W マスの H × W マスからなる迷路 S があります。上から i 行目、左から j 列目のマス は S_ij とあらわされ、 S_ij が「#」のとき壁であり、「.」のとき道です。整数 r、c が与えられるので、S_rc が壁かどうか判定してください。

# H W r c
# S_1
# S_2
# ...
# S_H

# 期待する出力
# S_rc が壁なら「Yes」を、壁ではないなら「No」と出力してください。

# 条件
# すべてのテストケースにおいて、以下の条件をみたします。

# ・ 1 ≦ H, W ≦ 100
# ・ 1 ≦ r ≦ H
# ・ 1 ≦ c ≦ W
# ・ S_i は「#」または「.」からなる W 文字の文字列

# 入力例1
# 3 4 1 2
# ..#.
# #.##
# ....

# 出力例1
# No

# 入力例2
# 1 1 1 1
# #

# 出力例2
# Yes


# 模範解答
H, W, r, c = map(int, input().split())
maze = [input() for _ in range(H)] # ユーザーからの入力(H行分の文字列)を受け取り、リストmazeに格納。

if maze[r-1][c-1] == "#": # 迷路のr行目とc列目のセルを指す。pythonではインデックス0から始まるため、-1を使用
# TypeError: 'builtin_function_or_method' object is not subscriptable：ビルトイン関数・メソッドに対して添字アクセス(subscripting)を試みた場合に発生。原因は変数が関数やメソッドに紐づけられていて、それをリストや文字列のようにインデックスでアクセス使用とした時に起こる。mazeを適切にリストと定義することで正常に動作する。
  print("Yes")
else:
  print("No")

# 文字が H 行 W 列 で与えられるので 2 次元配列などを用いれば正解できます。
# しかし、文字の配列は文字列とほぼ同義なので、配列の代わりに文字列を用いることで簡潔に実装することができます。

# アンパックと内包表記を用いて、入力値を受け取ります。
# リストや文字列のインデックスは 0 から始まることに注意して、壁かどうかの比較処理をおこないます。
